#!/bin/python3
'''
	Multithread server writen in python 3

	It has a "create_tcp_server" function that takes a host and a port. This creates a server and also handles the thread logic.
	Another function is "launch", which is the client handler. This gets called in a new thread everytime a new connection is made
	The final function is "brodcast_msg", and all this does is send a message to evey client in the server
	
	Clients are put in a list. This is done so it is easy to call the last client on the list to a new thread.
	So, when a new connection is established, take that connection and append it to the list. Then take the last element of the list,
	pass it to the "launch" method through a new thread and boom!. You have a thread for each client on the server.
'''
import socket
import threading

clients = []
client_side_keywords = [ "{clear}" ] # commnds that are for the client side will be ignored

def brodcast_msg( msg ):
	for c in range( 0 , len(clients) ):
			clients[c][0].send( bytes( msg.encode("utf-8") )  )

def launch( client , address , name ):
	global clients
	server_welcome_message = f"========================\n Welcome to '{socket.gethostname()}' server\n========================\n\n"
	
	print(f"\033[0;32mClient --[{name}@{address[0]}]-- connected\033[0m")
	client.send( bytes( server_welcome_message.encode("utf-8")) )
	brodcast_msg(f"Client --[{name}@{address[0]}]-- connected")

	try:
		while True:
			
			data = client.recv(2048).decode("utf-8")
			
			if data:
				
				if data == "{users}":
					hdr = "="*15
					client.sendall( bytes("===============\nServer:: '{users}' ".encode("utf-8") ) )
					fullmsg = ""
					for i in range(0 , len(clients)):
						fullmsg = fullmsg + "\t" +str(clients[i][2]) + "\n"
						
					client.sendall( bytes( f"\nList of connected users[\n{fullmsg}\n]\n{hdr}".encode("utf-8") ) )
					print(f"Server command --[{data}]-- was called by {name}")
					
				
				elif data == "{users} -num":
					msg = f"Number of users at the moment: {str( len(clients) )}"
					client.sendall( bytes( msg.encode("utf-8") ) )
					print(f"Server command --[{data}]-- was called by {name}")
					
					
				elif data == "{exit} ":
					brodcast_msg(f"Server:: {name} has been disconnected")
					clients.remove( ( client , address , name ) )
					client.close()
				
				elif data == "{server_welcome_message}":
					msg = server_welcome_message
					client.sendall( bytes( msg.encode("utf-8") ) )
					print(f"Server command --[{data}]-- was called by {name}")
					
				elif data in client_side_keywords:
					continue
					
				else:
					print(f"{name}@{address[0]} sent: --[{data}]--")
					data = "<" + str(name) + "> " + str(data)
					#client.sendall( bytes( data.encode("utf-8") ) )
					brodcast_msg( data )	
					
			else: # activates when a client disconnects !
				break
	finally:
		print(f"\033[0;33mClient [{name}@{address[0]}] disconnected !\033[0m")
		brodcast_msg(f"Client [{name}@{address[0]}] disconnected !")
		clients.remove( ( client , address , name ) )
		client.close()




def create_tcp_server( HOST , PORT):
	global clients
	sock = socket.socket( socket.AF_INET , socket.SOCK_STREAM ) #socket obj
	try:
		sock.bind( ( HOST , PORT ) )
		sock.listen( 10 )
		print(f'Created socket -> [{HOST}@{PORT}]\n\n')
		while True:
			client , address = sock.accept()
			name = client.recv(64).decode("utf-8")
			clients.append( ( client , address , name ) ) # add incomming connections to a list
			thrd = threading.Thread( target=launch , args=( clients[-1] ) ) # take the last connection from the list & handle it on a new thread
			thrd.start()
					
	except socket.error as se:
		print(f"\n\n\033[1;31mCould not open socket --> {se}\033[0m\n\n")
		sock.close()
		
	except Exception as e:
		print(f"\033[1;31mAn exceprion occured:\n{e}\033[0m")
		sock.close()
		
	except KeyboardInterrupt:
		print("\n====================\nForcebly stopped by user\n====================\n")
		sock.close() 
		
create_tcp_server( 'localhost' , 65534 )
